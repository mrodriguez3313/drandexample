import Client, { HTTP } from 'drand-client'
import fetch from 'node-fetch'
import AbortController from 'abort-controller'

global.fetch = fetch
global.AbortController = AbortController
const HEX = 16;
const WEIGHTS = { 0: 0.3, 1: 0.29, 2: 0.28, 3: 0.07, 4: 0.03, 5: .03 }

const chainHash = '8990e7a9aaed2ffed73dbd7092123d6f289930540d7651336225dc172e51b2ce' // (hex encoded)
const urls = [
  'https://api.drand.sh',
  'https://drand.cloudflare.com'
]

async function weightedRandom(prob) {

  const options = { chainHash }

  const client = await Client.wrap(HTTP.forURLs(urls, chainHash), options)

  // e.g. use the client to get the latest randomness round:
  const res = await client.get()
  // console.log(res.round, res.randomness)

  // assign randomness value as a string to a variable
  const drand = res.randomness

  // verify random number from the chain
  // ***********************************************





  // *****************************************************

  // Convert hexadecimal randomness value to decimal (base16 -> base10)
  // && grab the 20 right most digits
  var rand = parseInt(drand, HEX) % (10 ** 20)
  console.log(rand)

  // Cut down drand value to only the 16 left most digits
  var value = parseInt(rand.toString().slice(0, 16))
  console.log(value)

  // "normalize" rand value to be a percentage (between 0-1)
  const normal = value / (10 ** 16)
  console.log(normal)

  // This for loop selects which key:pair to return
  let i, sum = 0, r = normal;
  for (i in prob) {
    sum += prob[i];
    if (r <= sum) {
      return i;
    }
  }
}

// This function tests the accuracy of biased weights provided to weightedRandom()
function testProbs(iterations) {
  const counts = [0, 0, 0, 0, 0, 0];
  for (let i = 0; i <= iterations; i++) {
    res = parseInt(weightedRandom(WEIGHTS))
    counts[res]++
  }
  console.log(`counts arr ${counts}`)
  console.log(`counts arr ${counts[0] / iterations}, ${counts[1] / iterations}, ${counts[2] / iterations}, ${counts[3] / iterations}, ${counts[4] / iterations}, ${counts[5] / iterations}`)

}

// You can test either function by just commenting & uncommenting them
weightedRandom(WEIGHTS).then((biasedKey) => (console.log(biasedKey)))
// testProbs(10)

/* Things to note:
    Drand mainnet releases a random number every 30 seconds. The problem that arises is if you want to test if the biased randomness works or not, it would take a really long time to test.
    There is work to shorten this timeframe to 3 seconds, which is better, but its not as convenient as instant access of psuedo-random numbers like math.random() or crypto.getRandomValues().
    To test successfully, you would need the list of all random numbers generated by drand. But using these numbers in a live project is no longer random it's predictable.
    You can randomize them in an array, but then only you (a central authority) would know the correct order of things to occur. Which is no longer random to the whole system. 
    It's deterministic, but its just others that are in the dark.


    This "biased" algo is not sophisticated, weights are not changing every iteration to actively control supply.
    Ideally, we have a neural net that adjusts weights in a species-to-total BeeSupply ratio.
    Or some other algorithm that handled weights better, instead of just summation of key:pair values.
    This algorithm would have to run every time a bee is minted or after every couple minted bees to make sure the endangered-level ratios are maintained closer to what they should be.
*/